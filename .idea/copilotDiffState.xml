<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/D_Insert.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/D_Insert.cpp" />
              <option name="originalContent" value="#include &quot;../include/D_Insert.h&quot;&#10;#include &lt;nlohmann&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;chrono&gt;&#10;#include &lt;ctime&gt;&#10;&#10;void Insert::insertEnqueued(Enqueued &amp;enqueued) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO queue(id, gs_id, recipient_id, status, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6)&quot;, enqueued.id, enqueued.gs_id, enqueued.recipient_id, enqueued.status,enqueued.gs_app_id, enqueued.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Enqueued.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertSent(Sent &amp;sent) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO sent(id, display_phone_number, phone_number_id, conversation_expiration_timestamp, conversation_id, conversation_type, gs_id, meta_msg_id, pricing_billable, pricing_category, pricing_model, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)&quot;,&#10;            sent.id, sent.display_phone_number, sent.phone_number_id, sent.conversation_expiration_timestamp, sent.conversation_id, sent.conversation_type, sent.gs_id, sent.meta_msg_id, sent.pricing_billable, sent.pricing_category, sent.pricing_model, sent.recipient_id, sent.status, sent.changes_id, sent.gs_app_id, sent.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Sent.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertDelivered(Delivered &amp;delivered) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO delivered(id, display_phone_number, phone_number_id, conversation_id, conversation_type, gs_id, meta_msg_id, pricing_billable, pricing_category, pricing_model, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) ON CONFLICT (id) DO NOTHING&quot;, delivered.id, delivered.display_phone_number, delivered.phone_number_id, delivered.conversation_id, delivered.conversation_id, delivered.conversation_id, delivered.conversation_type, delivered.gs_id, delivered.meta_msg_id, delivered.pricing_billable, delivered.pricing_category, delivered.pricing_model, delivered.recipient_id, delivered.status, delivered.changes_id, delivered.gs_app_id, delivered.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Delivered.\n&quot;;&#10;        }&#10;&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertRead(Read &amp;read) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO read(id, display_phone_number, phone_number_id, gs_id, meta_msg_id, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) ON CONFLICT (id) DO NOTHING&quot;, read.id, read.display_phone_number, read.phone_number_id, read.gs_id, read.meta_msg_id, read.recipient_id, read.status, read.changes_id, read.status, read.changes_id, read.gs_app_id, read.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Read.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertFailed(Failed &amp;failed) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO failed(id, display_phone_number, phone_number_id, erro_code, erro_details, erro_message, title, gs_id, meta_msg_id, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)&quot;, failed.id, failed.display_phone_number, failed.phone_number_id, failed.error_code, failed.error_details, failed.error_message, failed.title, failed.gs_id, failed.meta_msg_id, failed.recipient_id, failed.recipient_id, failed.status, failed.changes_id, failed.gs_app_id, failed.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Failed.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertUnmapped(std::string &amp;data) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO unmapped(valor) VALUES ($1)&quot;, data);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Unmapped.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertTemplateError(TemplateError &amp;err) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO template_errors(gs_id, recipient_id, error_code, error_title, status, timestamp, raw_json) VALUES ($1, $2, $3, $4, $5, $6, $7)&quot;, err.gs_id, err.recipient_id, err.error_code, err.error_title, err.status, err.timestamp, err.raw_json);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting TemplateError.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertErrorPayload(std::string &amp;payload) {&#10;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/D_Insert.h&quot;&#10;#include &lt;nlohmann&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;chrono&gt;&#10;#include &lt;ctime&gt;&#10;&#10;void Insert::insertEnqueued(Enqueued &amp;enqueued) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO queue(id, gs_id, recipient_id, status, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6)&quot;, enqueued.id, enqueued.gs_id, enqueued.recipient_id, enqueued.status,enqueued.gs_app_id, enqueued.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Enqueued.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertSent(Sent &amp;sent) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO sent(id, display_phone_number, phone_number_id, conversation_expiration_timestamp, conversation_id, conversation_type, gs_id, meta_msg_id, pricing_billable, pricing_category, pricing_model, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)&quot;,&#10;            sent.id, sent.display_phone_number, sent.phone_number_id, sent.conversation_expiration_timestamp, sent.conversation_id, sent.conversation_type, sent.gs_id, sent.meta_msg_id, sent.pricing_billable, sent.pricing_category, sent.pricing_model, sent.recipient_id, sent.status, sent.changes_id, sent.gs_app_id, sent.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Sent.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertDelivered(Delivered &amp;delivered) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO delivered(id, display_phone_number, phone_number_id, conversation_id, conversation_type, gs_id, meta_msg_id, pricing_billable, pricing_category, pricing_model, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) ON CONFLICT (id) DO NOTHING&quot;, delivered.id, delivered.display_phone_number, delivered.phone_number_id, delivered.conversation_id, delivered.conversation_id, delivered.conversation_id, delivered.conversation_type, delivered.gs_id, delivered.meta_msg_id, delivered.pricing_billable, delivered.pricing_category, delivered.pricing_model, delivered.recipient_id, delivered.status, delivered.changes_id, delivered.gs_app_id, delivered.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Delivered.\n&quot;;&#10;        }&#10;&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertRead(Read &amp;read) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO read(id, display_phone_number, phone_number_id, gs_id, meta_msg_id, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) ON CONFLICT (id) DO NOTHING&quot;, read.id, read.display_phone_number, read.phone_number_id, read.gs_id, read.meta_msg_id, read.recipient_id, read.status, read.changes_id, read.status, read.changes_id, read.gs_app_id, read.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Read.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertFailed(Failed &amp;failed) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO failed(id, display_phone_number, phone_number_id, erro_code, erro_details, erro_message, title, gs_id, meta_msg_id, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)&quot;, failed.id, failed.display_phone_number, failed.phone_number_id, failed.error_code, failed.error_details, failed.error_message, failed.title, failed.gs_id, failed.meta_msg_id, failed.recipient_id, failed.recipient_id, failed.status, failed.changes_id, failed.gs_app_id, failed.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Failed.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertUnmapped(std::string &amp;data) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO unmapped(valor) VALUES ($1)&quot;, data);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Unmapped.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertTemplateError(TemplateError &amp;err) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO template_errors(gs_id, recipient_id, error_code, error_title, status, timestamp, raw_json) VALUES ($1, $2, $3, $4, $5, $6, $7)&quot;, err.gs_id, err.recipient_id, err.error_code, err.error_title, err.status, err.timestamp, err.raw_json);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting TemplateError.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertErrorPayload(std::string &amp;payload) {&#10;    try {&#10;        // Parse the JSON payload&#10;        nlohmann::json error_json = nlohmann::json::parse(payload);&#10;        &#10;        // Check if required fields exist&#10;        if (error_json.contains(&quot;gs_id&quot;) &amp;&amp; error_json[&quot;gs_id&quot;].is_string() &amp;&amp;&#10;            error_json.contains(&quot;recipient_id&quot;) &amp;&amp; error_json[&quot;recipient_id&quot;].is_string() &amp;&amp;&#10;            error_json.contains(&quot;status&quot;) &amp;&amp; error_json[&quot;status&quot;].is_string() &amp;&amp;&#10;            error_json.contains(&quot;timestamp&quot;) &amp;&amp; error_json[&quot;timestamp&quot;].is_number()) {&#10;            &#10;            // Extract values from JSON&#10;            std::string gs_id_str = error_json[&quot;gs_id&quot;].get&lt;std::string&gt;();&#10;            std::string recipient_id = error_json[&quot;recipient_id&quot;].get&lt;std::string&gt;();&#10;            std::string status = error_json[&quot;status&quot;].get&lt;std::string&gt;();&#10;            int64_t timestamp_val = error_json[&quot;timestamp&quot;].get&lt;int64_t&gt;();&#10;            &#10;            // Convert timestamp (milliseconds to seconds)&#10;            int64_t timestamp_secs = timestamp_val / 1000;&#10;            &#10;            // Format timestamp as string (ISO 8601 format)&#10;            time_t time_val = static_cast&lt;time_t&gt;(timestamp_secs);&#10;            char time_buf[30];&#10;            std::strftime(time_buf, sizeof(time_buf), &quot;%Y-%m-%d %H:%M:%S&quot;, std::gmtime(&amp;time_val));&#10;            std::string timestamp_str(time_buf);&#10;            &#10;            // Check if errors array exists and has at least one element&#10;            if (error_json.contains(&quot;errors&quot;) &amp;&amp; error_json[&quot;errors&quot;].is_array() &amp;&amp; !error_json[&quot;errors&quot;].empty()) {&#10;                const nlohmann::json&amp; first_error = error_json[&quot;errors&quot;][0];&#10;                &#10;                // Get error code (default to 0 if not found)&#10;                int error_code = 0;&#10;                if (first_error.contains(&quot;code&quot;) &amp;&amp; first_error[&quot;code&quot;].is_number()) {&#10;                    error_code = first_error[&quot;code&quot;].get&lt;int&gt;();&#10;                }&#10;                &#10;                // Get error title (default to &quot;Unknown error&quot; if not found)&#10;                std::string error_title = &quot;Unknown error&quot;;&#10;                if (first_error.contains(&quot;title&quot;) &amp;&amp; first_error[&quot;title&quot;].is_string()) {&#10;                    error_title = first_error[&quot;title&quot;].get&lt;std::string&gt;();&#10;                }&#10;                &#10;                // Create TemplateError object and insert it&#10;                TemplateError err;&#10;                err.gs_id = gs_id_str;&#10;                err.recipient_id = recipient_id;&#10;                err.error_code = error_code;&#10;                err.error_title = error_title;&#10;                err.status = status;&#10;                err.timestamp = timestamp_str;&#10;                err.raw_json = payload;&#10;                &#10;                insertTemplateError(err);&#10;                return;&#10;            }&#10;        }&#10;    } catch (const nlohmann::json::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;JSON parsing error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;Error processing payload: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;    }&#10;    &#10;    // If we reach here, either JSON parsing failed or required fields were missing&#10;    // Fall back to inserting as unmapped data&#10;    insertUnmapped(payload);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>