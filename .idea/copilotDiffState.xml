<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/include/Rabbit.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/Rabbit.h" />
              <option name="originalContent" value="#ifndef RABBIT_H&#10;#define RABBIT_H&#10;&#10;#include &lt;rabbitmq-c/amqp.h&gt;&#10;#include &lt;rabbitmq-c/tcp_socket.h&gt;&#10;#include &lt;string&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;functional&gt;&#10;&#10;class Rabbit {&#10;private:&#10;    amqp_connection_state_t conn;&#10;    amqp_socket_t* socket;&#10;    std::string hostname;&#10;    int port;&#10;    std::string username;&#10;    std::string password;&#10;    std::string vhost;&#10;&#10;    void checkReply(amqp_rpc_reply_t reply, const std::string&amp; context);&#10;&#10;public:&#10;    Rabbit(const std::string&amp; host = &quot;localhost&quot;,&#10;           int port = 5672,&#10;           const std::string&amp; user = &quot;guest&quot;,&#10;           const std::string&amp; pass = &quot;guest&quot;,&#10;           const std::string&amp; vhost = &quot;/&quot;);&#10;    ~Rabbit();&#10;&#10;    bool connect();&#10;    void disconnect();&#10;    bool isConnected() const;&#10;&#10;    bool openChannel(int channel);&#10;    void closeChannel(int channel);&#10;&#10;    void declareQueue(int channel, const std::string&amp; queueName, bool durable = true,&#10;                      bool exclusive = false, bool autoDelete = false);&#10;    void bindQueue(int channel, const std::string&amp; queueName,&#10;                   const std::string&amp; exchangeName, const std::string&amp; routingKey);&#10;&#10;    void declareExchange(int channel, const std::string&amp; exchangeName,&#10;                         const std::string&amp; exchangeType, bool durable = true,&#10;                         bool autoDelete = false);&#10;&#10;    bool publish(int channel, const std::string&amp; exchange, const std::string&amp; routingKey,&#10;                const std::string&amp; message, bool mandatory = false);&#10;&#10;    bool basicConsume(int channel, const std::string&amp; queueName,&#10;                     const std::string&amp; consumerTag = &quot;&quot;);&#10;    bool getMessage(int channel, std::string&amp; message, int timeoutMs = 1000);&#10;&#10;    bool consumeMessages(int channel, const std::string&amp; queueName,&#10;                        std::function&lt;void(const std::string&amp;)&gt; callback,&#10;                        const std::string&amp; consumerTag = &quot;&quot;);&#10;};&#10;&#10;#endif" />
              <option name="updatedContent" value="#ifndef RABBIT_H&#10;#define RABBIT_H&#10;&#10;#include &lt;rabbitmq-c/amqp.h&gt;&#10;#include &lt;rabbitmq-c/tcp_socket.h&gt;&#10;#include &lt;string&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;functional&gt;&#10;#include &lt;optional&gt;&#10;&#10;class Rabbit {&#10;private:&#10;    amqp_connection_state_t conn;&#10;    amqp_socket_t* socket;&#10;    std::string hostname;&#10;    int port;&#10;    std::string username;&#10;    std::string password;&#10;    std::string vhost;&#10;&#10;    void checkReply(amqp_rpc_reply_t reply, const std::string&amp; context);&#10;&#10;public:&#10;    Rabbit(const std::string&amp; host = &quot;localhost&quot;,&#10;           int port = 5672,&#10;           const std::string&amp; user = &quot;guest&quot;,&#10;           const std::string&amp; pass = &quot;guest&quot;,&#10;           const std::string&amp; vhost = &quot;/&quot;);&#10;    ~Rabbit();&#10;&#10;    bool connect();&#10;    void disconnect();&#10;    bool isConnected() const;&#10;&#10;    bool openChannel(int channel);&#10;    void closeChannel(int channel);&#10;&#10;    void declareQueue(int channel, const std::string&amp; queueName, bool durable = true,&#10;                      bool exclusive = false, bool autoDelete = false);&#10;    void bindQueue(int channel, const std::string&amp; queueName,&#10;                   const std::string&amp; exchangeName, const std::string&amp; routingKey);&#10;&#10;    void declareExchange(int channel, const std::string&amp; exchangeName,&#10;                         const std::string&amp; exchangeType, bool durable = true,&#10;                         bool autoDelete = false);&#10;&#10;    bool publish(int channel, const std::string&amp; exchange, const std::string&amp; routingKey,&#10;                const std::string&amp; message, bool mandatory = false);&#10;&#10;    bool basicConsume(int channel, const std::string&amp; queueName,&#10;                     const std::string&amp; consumerTag = &quot;&quot;);&#10;    std::optional&lt;std::string&gt; getMessage(int channel, int timeoutMs = 1000);&#10;&#10;    bool consumeMessages(int channel, const std::string&amp; queueName,&#10;                        std::function&lt;void(const std::string&amp;)&gt; callback,&#10;                        const std::string&amp; consumerTag = &quot;&quot;);&#10;};&#10;&#10;#endif" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/include/Utils.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/Utils.h" />
              <option name="originalContent" value="#ifndef UTILS_H&#10;#define UTILS_H&#10;&#10;#include &lt;string&gt;&#10;&#10;class Utils {&#10;public:&#10;    Utils() = delete;&#10;    static void getTimestamp(std::string timestamp);&#10;};&#10;&#10;#endif //UTILS_H&#10;" />
              <option name="updatedContent" value="#ifndef UTILS_H&#10;#define UTILS_H&#10;&#10;#include &lt;string&gt;&#10;#include &lt;chrono&gt;&#10;&#10;class Utils {&#10;public:&#10;    Utils() = delete;&#10;    static std::chrono::system_clock::time_point getTimestamp(std::string timestamp);&#10;};&#10;&#10;#endif //UTILS_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Rabbit.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Rabbit.cpp" />
              <option name="originalContent" value="#include &quot;../include/Rabbit.h&quot;&#10;#include &lt;rabbitmq-c/framing.h&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;thread&gt;&#10;#include &lt;chrono&gt;&#10;&#10;Rabbit::Rabbit(const std::string&amp; host, int port, const std::string&amp; user,&#10;               const std::string&amp; pass, const std::string&amp; vhost)&#10;    : hostname(host), port(port), username(user), password(pass), vhost(vhost), conn(nullptr), socket(nullptr) {&#10;}&#10;&#10;Rabbit::~Rabbit() {&#10;    disconnect();&#10;}&#10;&#10;void Rabbit::checkReply(amqp_rpc_reply_t reply, const std::string&amp; context) {&#10;    switch (reply.reply_type) {&#10;        case AMQP_RESPONSE_NORMAL:&#10;            return;&#10;        case AMQP_RESPONSE_NONE:&#10;            throw std::runtime_error(context + &quot;: missing RPC reply&quot;);&#10;        case AMQP_RESPONSE_LIBRARY_EXCEPTION:&#10;            throw std::runtime_error(context + &quot;: &quot; + amqp_error_string2(reply.library_error));&#10;        case AMQP_RESPONSE_SERVER_EXCEPTION:&#10;            if (reply.reply.id == AMQP_CHANNEL_CLOSE_METHOD) {&#10;                amqp_channel_close_t *close = (amqp_channel_close_t *)reply.reply.decoded;&#10;                throw std::runtime_error(context + &quot;: channel closed - &quot; +&#10;                    std::string((char *)close-&gt;reply_text.bytes, close-&gt;reply_text.len));&#10;            } else if (reply.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {&#10;                amqp_connection_close_t *close = (amqp_connection_close_t *)reply.reply.decoded;&#10;                throw std::runtime_error(context + &quot;: connection closed - &quot; +&#10;                    std::string((char *)close-&gt;reply_text.bytes, close-&gt;reply_text.len));&#10;            }&#10;            throw std::runtime_error(context + &quot;: server exception&quot;);&#10;        default:&#10;            throw std::runtime_error(context + &quot;: unknown reply type&quot;);&#10;    }&#10;}&#10;&#10;bool Rabbit::connect() {&#10;    conn = amqp_new_connection();&#10;    if (!conn) {&#10;        std::cerr &lt;&lt; &quot;Failed to create connection&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    socket = amqp_tcp_socket_new(conn);&#10;    if (!socket) {&#10;        std::cerr &lt;&lt; &quot;Failed to create TCP socket&quot; &lt;&lt; std::endl;&#10;        amqp_destroy_connection(conn);&#10;        conn = nullptr;&#10;        return false;&#10;    }&#10;&#10;    int status = amqp_socket_open(socket, hostname.c_str(), port);&#10;    if (status) {&#10;        std::cerr &lt;&lt; &quot;Failed to open TCP socket: &quot; &lt;&lt; status &lt;&lt; std::endl;&#10;        amqp_destroy_connection(conn);&#10;        conn = nullptr;&#10;        socket = nullptr;&#10;        return false;&#10;    }&#10;&#10;    amqp_rpc_reply_t reply = amqp_login(conn, vhost.c_str(), 0, 131072, 0,&#10;        AMQP_SASL_METHOD_PLAIN, username.c_str(), password.c_str());&#10;&#10;    try {&#10;        checkReply(reply, &quot;Login&quot;);&#10;        return true;&#10;    } catch (const std::runtime_error&amp; e) {&#10;        std::cerr &lt;&lt; &quot;Error during connection: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        amqp_destroy_connection(conn);&#10;        conn = nullptr;&#10;        socket = nullptr;&#10;        return false;&#10;    }&#10;}&#10;&#10;void Rabbit::disconnect() {&#10;    if (conn) {&#10;        try {&#10;            amqp_rpc_reply_t reply = amqp_connection_close(conn, AMQP_REPLY_SUCCESS);&#10;            checkReply(reply, &quot;Closing connection&quot;);&#10;        } catch (const std::exception&amp; e) {&#10;            std::cerr &lt;&lt; &quot;Error during disconnect: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        }&#10;&#10;        amqp_destroy_connection(conn);&#10;        conn = nullptr;&#10;        socket = nullptr;&#10;    }&#10;}&#10;&#10;bool Rabbit::isConnected() const {&#10;    return conn != nullptr;&#10;}&#10;&#10;bool Rabbit::openChannel(int channel) {&#10;    if (!isConnected()) {&#10;        std::cerr &lt;&lt; &quot;Not connected to RabbitMQ&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    amqp_channel_open(conn, channel);&#10;    try {&#10;        checkReply(amqp_get_rpc_reply(conn), &quot;Opening channel&quot;);&#10;        return true;&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; &quot;Failed to open channel: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;}&#10;&#10;void Rabbit::closeChannel(int channel) {&#10;    if (!isConnected()) {&#10;        return;&#10;    }&#10;&#10;    try {&#10;        amqp_channel_close(conn, channel, AMQP_REPLY_SUCCESS);&#10;        checkReply(amqp_get_rpc_reply(conn), &quot;Closing channel&quot;);&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; &quot;Error closing channel: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;    }&#10;}&#10;&#10;void Rabbit::declareQueue(int channel, const std::string&amp; queueName, bool durable,&#10;                           bool exclusive, bool autoDelete) {&#10;    if (!isConnected()) {&#10;        throw std::runtime_error(&quot;Not connected to RabbitMQ&quot;);&#10;    }&#10;&#10;    amqp_queue_declare_ok_t *r = amqp_queue_declare(conn, channel,&#10;        amqp_cstring_bytes(queueName.c_str()),&#10;        0, // passive&#10;        durable ? 1 : 0,&#10;        exclusive ? 1 : 0,&#10;        autoDelete ? 1 : 0,&#10;        amqp_empty_table);&#10;&#10;    checkReply(amqp_get_rpc_reply(conn), &quot;Declaring queue&quot;);&#10;}&#10;&#10;void Rabbit::bindQueue(int channel, const std::string&amp; queueName,&#10;                        const std::string&amp; exchangeName, const std::string&amp; routingKey) {&#10;    if (!isConnected()) {&#10;        throw std::runtime_error(&quot;Not connected to RabbitMQ&quot;);&#10;    }&#10;&#10;    amqp_queue_bind(conn, channel,&#10;        amqp_cstring_bytes(queueName.c_str()),&#10;        amqp_cstring_bytes(exchangeName.c_str()),&#10;        amqp_cstring_bytes(routingKey.c_str()),&#10;        amqp_empty_table);&#10;&#10;    checkReply(amqp_get_rpc_reply(conn), &quot;Binding queue&quot;);&#10;}&#10;&#10;void Rabbit::declareExchange(int channel, const std::string&amp; exchangeName,&#10;                             const std::string&amp; exchangeType, bool durable, bool autoDelete) {&#10;    if (!isConnected()) {&#10;        throw std::runtime_error(&quot;Not connected to RabbitMQ&quot;);&#10;    }&#10;&#10;    amqp_exchange_declare(conn, channel,&#10;        amqp_cstring_bytes(exchangeName.c_str()),&#10;        amqp_cstring_bytes(exchangeType.c_str()),&#10;        0,&#10;        durable ? 1 : 0,&#10;        autoDelete ? 1 : 0,&#10;        0,&#10;        amqp_empty_table);&#10;&#10;    checkReply(amqp_get_rpc_reply(conn), &quot;Declaring exchange&quot;);&#10;}&#10;&#10;bool Rabbit::publish(int channel, const std::string&amp; exchange, const std::string&amp; routingKey,&#10;                    const std::string&amp; message, bool mandatory) {&#10;    if (!isConnected()) {&#10;        std::cerr &lt;&lt; &quot;Not connected to RabbitMQ&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    amqp_basic_properties_t props;&#10;    props._flags = AMQP_BASIC_CONTENT_TYPE_FLAG | AMQP_BASIC_DELIVERY_MODE_FLAG;&#10;    props.content_type = amqp_cstring_bytes(&quot;text/plain&quot;);&#10;    props.delivery_mode = 2;&#10;&#10;    int status = amqp_basic_publish(conn, channel,&#10;        amqp_cstring_bytes(exchange.c_str()),&#10;        amqp_cstring_bytes(routingKey.c_str()),&#10;        mandatory ? 1 : 0,&#10;        0,&#10;        &amp;props,&#10;        amqp_cstring_bytes(message.c_str()));&#10;&#10;    if (status != 0) {&#10;        std::cerr &lt;&lt; &quot;Failed to publish message: &quot; &lt;&lt; status &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    return true;&#10;}&#10;&#10;bool Rabbit::basicConsume(int channel, const std::string&amp; queueName, const std::string&amp; consumerTag) {&#10;    if (!isConnected()) {&#10;        std::cerr &lt;&lt; &quot;Not connected to RabbitMQ&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    amqp_basic_consume(conn, channel,&#10;        amqp_cstring_bytes(queueName.c_str()),&#10;        consumerTag.empty() ? amqp_empty_bytes : amqp_cstring_bytes(consumerTag.c_str()),&#10;        0,&#10;        1,&#10;        0,&#10;        amqp_empty_table);&#10;&#10;    try {&#10;        checkReply(amqp_get_rpc_reply(conn), &quot;Starting consumer&quot;);&#10;        return true;&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; &quot;Failed to start consumer: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;}&#10;&#10;bool Rabbit::getMessage(int channel, std::string&amp; message, int timeoutMs) {&#10;    if (!isConnected()) {&#10;        std::cerr &lt;&lt; &quot;Not connected to RabbitMQ&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    struct timeval timeout;&#10;    timeout.tv_sec = timeoutMs / 1000;&#10;    timeout.tv_usec = (timeoutMs % 1000) * 1000;&#10;&#10;    amqp_envelope_t envelope;&#10;    amqp_maybe_release_buffers(conn);&#10;&#10;    amqp_rpc_reply_t res = amqp_consume_message(conn, &amp;envelope, &amp;timeout, 0);&#10;&#10;    if (res.reply_type == AMQP_RESPONSE_NORMAL) {&#10;        message = std::string(static_cast&lt;char*&gt;(envelope.message.body.bytes),&#10;                             envelope.message.body.len);&#10;        amqp_destroy_envelope(&amp;envelope);&#10;        return true;&#10;    } else if (res.reply_type == AMQP_RESPONSE_LIBRARY_EXCEPTION &amp;&amp;&#10;               res.library_error == AMQP_STATUS_TIMEOUT) {&#10;        return false;&#10;    } else {&#10;        try {&#10;            checkReply(res, &quot;Consuming message&quot;);&#10;        } catch (const std::exception&amp; e) {&#10;            std::cerr &lt;&lt; &quot;Error consuming message: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        }&#10;        return false;&#10;    }&#10;}&#10;&#10;bool Rabbit::consumeMessages(int channel, const std::string&amp; queueName,&#10;                            std::function&lt;void(const std::string&amp;)&gt; callback,&#10;                            const std::string&amp; consumerTag) {&#10;    if (!basicConsume(channel, queueName, consumerTag)) {&#10;        return false;&#10;    }&#10;&#10;    try {&#10;        while (true) {&#10;            std::string message;&#10;            if (getMessage(channel, message, 100)) {&#10;                callback(message);&#10;            } else {&#10;                std::this_thread::sleep_for(std::chrono::milliseconds(100));&#10;            }&#10;        }&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; &quot;Error in consume loop: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    return true;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/Rabbit.h&quot;&#10;#include &lt;rabbitmq-c/framing.h&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;cstring&gt;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;thread&gt;&#10;#include &lt;chrono&gt;&#10;#include &lt;optional&gt;&#10;&#10;Rabbit::Rabbit(const std::string&amp; host, int port, const std::string&amp; user,&#10;               const std::string&amp; pass, const std::string&amp; vhost)&#10;    : hostname(host), port(port), username(user), password(pass), vhost(vhost), conn(nullptr), socket(nullptr) {&#10;}&#10;&#10;Rabbit::~Rabbit() {&#10;    disconnect();&#10;}&#10;&#10;void Rabbit::checkReply(amqp_rpc_reply_t reply, const std::string&amp; context) {&#10;    switch (reply.reply_type) {&#10;        case AMQP_RESPONSE_NORMAL:&#10;            return;&#10;        case AMQP_RESPONSE_NONE:&#10;            throw std::runtime_error(context + &quot;: missing RPC reply&quot;);&#10;        case AMQP_RESPONSE_LIBRARY_EXCEPTION:&#10;            throw std::runtime_error(context + &quot;: &quot; + amqp_error_string2(reply.library_error));&#10;        case AMQP_RESPONSE_SERVER_EXCEPTION:&#10;            if (reply.reply.id == AMQP_CHANNEL_CLOSE_METHOD) {&#10;                amqp_channel_close_t *close = (amqp_channel_close_t *)reply.reply.decoded;&#10;                throw std::runtime_error(context + &quot;: channel closed - &quot; +&#10;                    std::string((char *)close-&gt;reply_text.bytes, close-&gt;reply_text.len));&#10;            } else if (reply.reply.id == AMQP_CONNECTION_CLOSE_METHOD) {&#10;                amqp_connection_close_t *close = (amqp_connection_close_t *)reply.reply.decoded;&#10;                throw std::runtime_error(context + &quot;: connection closed - &quot; +&#10;                    std::string((char *)close-&gt;reply_text.bytes, close-&gt;reply_text.len));&#10;            }&#10;            throw std::runtime_error(context + &quot;: server exception&quot;);&#10;        default:&#10;            throw std::runtime_error(context + &quot;: unknown reply type&quot;);&#10;    }&#10;}&#10;&#10;bool Rabbit::connect() {&#10;    conn = amqp_new_connection();&#10;    if (!conn) {&#10;        std::cerr &lt;&lt; &quot;Failed to create connection&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    socket = amqp_tcp_socket_new(conn);&#10;    if (!socket) {&#10;        std::cerr &lt;&lt; &quot;Failed to create TCP socket&quot; &lt;&lt; std::endl;&#10;        amqp_destroy_connection(conn);&#10;        conn = nullptr;&#10;        return false;&#10;    }&#10;&#10;    int status = amqp_socket_open(socket, hostname.c_str(), port);&#10;    if (status) {&#10;        std::cerr &lt;&lt; &quot;Failed to open TCP socket: &quot; &lt;&lt; status &lt;&lt; std::endl;&#10;        amqp_destroy_connection(conn);&#10;        conn = nullptr;&#10;        socket = nullptr;&#10;        return false;&#10;    }&#10;&#10;    amqp_rpc_reply_t reply = amqp_login(conn, vhost.c_str(), 0, 131072, 0,&#10;        AMQP_SASL_METHOD_PLAIN, username.c_str(), password.c_str());&#10;&#10;    try {&#10;        checkReply(reply, &quot;Login&quot;);&#10;        return true;&#10;    } catch (const std::runtime_error&amp; e) {&#10;        std::cerr &lt;&lt; &quot;Error during connection: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        amqp_destroy_connection(conn);&#10;        conn = nullptr;&#10;        socket = nullptr;&#10;        return false;&#10;    }&#10;}&#10;&#10;void Rabbit::disconnect() {&#10;    if (conn) {&#10;        try {&#10;            amqp_rpc_reply_t reply = amqp_connection_close(conn, AMQP_REPLY_SUCCESS);&#10;            checkReply(reply, &quot;Closing connection&quot;);&#10;        } catch (const std::exception&amp; e) {&#10;            std::cerr &lt;&lt; &quot;Error during disconnect: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        }&#10;&#10;        amqp_destroy_connection(conn);&#10;        conn = nullptr;&#10;        socket = nullptr;&#10;    }&#10;}&#10;&#10;bool Rabbit::isConnected() const {&#10;    return conn != nullptr;&#10;}&#10;&#10;bool Rabbit::openChannel(int channel) {&#10;    if (!isConnected()) {&#10;        std::cerr &lt;&lt; &quot;Not connected to RabbitMQ&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    amqp_channel_open(conn, channel);&#10;    try {&#10;        checkReply(amqp_get_rpc_reply(conn), &quot;Opening channel&quot;);&#10;        return true;&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; &quot;Failed to open channel: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;}&#10;&#10;void Rabbit::closeChannel(int channel) {&#10;    if (!isConnected()) {&#10;        return;&#10;    }&#10;&#10;    try {&#10;        amqp_channel_close(conn, channel, AMQP_REPLY_SUCCESS);&#10;        checkReply(amqp_get_rpc_reply(conn), &quot;Closing channel&quot;);&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; &quot;Error closing channel: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;    }&#10;}&#10;&#10;void Rabbit::declareQueue(int channel, const std::string&amp; queueName, bool durable,&#10;                           bool exclusive, bool autoDelete) {&#10;    if (!isConnected()) {&#10;        throw std::runtime_error(&quot;Not connected to RabbitMQ&quot;);&#10;    }&#10;&#10;    amqp_queue_declare_ok_t *r = amqp_queue_declare(conn, channel,&#10;        amqp_cstring_bytes(queueName.c_str()),&#10;        0, // passive&#10;        durable ? 1 : 0,&#10;        exclusive ? 1 : 0,&#10;        autoDelete ? 1 : 0,&#10;        amqp_empty_table);&#10;&#10;    checkReply(amqp_get_rpc_reply(conn), &quot;Declaring queue&quot;);&#10;}&#10;&#10;void Rabbit::bindQueue(int channel, const std::string&amp; queueName,&#10;                        const std::string&amp; exchangeName, const std::string&amp; routingKey) {&#10;    if (!isConnected()) {&#10;        throw std::runtime_error(&quot;Not connected to RabbitMQ&quot;);&#10;    }&#10;&#10;    amqp_queue_bind(conn, channel,&#10;        amqp_cstring_bytes(queueName.c_str()),&#10;        amqp_cstring_bytes(exchangeName.c_str()),&#10;        amqp_cstring_bytes(routingKey.c_str()),&#10;        amqp_empty_table);&#10;&#10;    checkReply(amqp_get_rpc_reply(conn), &quot;Binding queue&quot;);&#10;}&#10;&#10;void Rabbit::declareExchange(int channel, const std::string&amp; exchangeName,&#10;                             const std::string&amp; exchangeType, bool durable, bool autoDelete) {&#10;    if (!isConnected()) {&#10;        throw std::runtime_error(&quot;Not connected to RabbitMQ&quot;);&#10;    }&#10;&#10;    amqp_exchange_declare(conn, channel,&#10;        amqp_cstring_bytes(exchangeName.c_str()),&#10;        amqp_cstring_bytes(exchangeType.c_str()),&#10;        0,&#10;        durable ? 1 : 0,&#10;        autoDelete ? 1 : 0,&#10;        0,&#10;        amqp_empty_table);&#10;&#10;    checkReply(amqp_get_rpc_reply(conn), &quot;Declaring exchange&quot;);&#10;}&#10;&#10;bool Rabbit::publish(int channel, const std::string&amp; exchange, const std::string&amp; routingKey,&#10;                    const std::string&amp; message, bool mandatory) {&#10;    if (!isConnected()) {&#10;        std::cerr &lt;&lt; &quot;Not connected to RabbitMQ&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    amqp_basic_properties_t props;&#10;    props._flags = AMQP_BASIC_CONTENT_TYPE_FLAG | AMQP_BASIC_DELIVERY_MODE_FLAG;&#10;    props.content_type = amqp_cstring_bytes(&quot;text/plain&quot;);&#10;    props.delivery_mode = 2;&#10;&#10;    int status = amqp_basic_publish(conn, channel,&#10;        amqp_cstring_bytes(exchange.c_str()),&#10;        amqp_cstring_bytes(routingKey.c_str()),&#10;        mandatory ? 1 : 0,&#10;        0,&#10;        &amp;props,&#10;        amqp_cstring_bytes(message.c_str()));&#10;&#10;    if (status != 0) {&#10;        std::cerr &lt;&lt; &quot;Failed to publish message: &quot; &lt;&lt; status &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    return true;&#10;}&#10;&#10;bool Rabbit::basicConsume(int channel, const std::string&amp; queueName, const std::string&amp; consumerTag) {&#10;    if (!isConnected()) {&#10;        std::cerr &lt;&lt; &quot;Not connected to RabbitMQ&quot; &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    amqp_basic_consume(conn, channel,&#10;        amqp_cstring_bytes(queueName.c_str()),&#10;        consumerTag.empty() ? amqp_empty_bytes : amqp_cstring_bytes(consumerTag.c_str()),&#10;        0,&#10;        1,&#10;        0,&#10;        amqp_empty_table);&#10;&#10;    try {&#10;        checkReply(amqp_get_rpc_reply(conn), &quot;Starting consumer&quot;);&#10;        return true;&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; &quot;Failed to start consumer: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;}&#10;&#10;std::optional&lt;std::string&gt; Rabbit::getMessage(int channel, int timeoutMs) {&#10;    if (!isConnected()) {&#10;        std::cerr &lt;&lt; &quot;Not connected to RabbitMQ&quot; &lt;&lt; std::endl;&#10;        return std::nullopt;&#10;    }&#10;&#10;    struct timeval timeout;&#10;    timeout.tv_sec = timeoutMs / 1000;&#10;    timeout.tv_usec = (timeoutMs % 1000) * 1000;&#10;&#10;    amqp_envelope_t envelope;&#10;    amqp_maybe_release_buffers(conn);&#10;&#10;    amqp_rpc_reply_t res = amqp_consume_message(conn, &amp;envelope, &amp;timeout, 0);&#10;&#10;    if (res.reply_type == AMQP_RESPONSE_NORMAL) {&#10;        std::string message(static_cast&lt;char*&gt;(envelope.message.body.bytes),&#10;                           envelope.message.body.len);&#10;        amqp_destroy_envelope(&amp;envelope);&#10;        return message;&#10;    } else if (res.reply_type == AMQP_RESPONSE_LIBRARY_EXCEPTION &amp;&amp;&#10;               res.library_error == AMQP_STATUS_TIMEOUT) {&#10;        return std::nullopt;&#10;    } else {&#10;        try {&#10;            checkReply(res, &quot;Consuming message&quot;);&#10;        } catch (const std::exception&amp; e) {&#10;            std::cerr &lt;&lt; &quot;Error consuming message: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        }&#10;        return std::nullopt;&#10;    }&#10;}&#10;&#10;bool Rabbit::consumeMessages(int channel, const std::string&amp; queueName,&#10;                            std::function&lt;void(const std::string&amp;)&gt; callback,&#10;                            const std::string&amp; consumerTag) {&#10;    if (!basicConsume(channel, queueName, consumerTag)) {&#10;        return false;&#10;    }&#10;&#10;    try {&#10;        while (true) {&#10;            auto messageOpt = getMessage(channel, 100);&#10;            if (messageOpt) {&#10;                callback(*messageOpt);&#10;            } else {&#10;                std::this_thread::sleep_for(std::chrono::milliseconds(100));&#10;            }&#10;        }&#10;    } catch (const std::exception&amp; e) {&#10;        std::cerr &lt;&lt; &quot;Error in consume loop: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;&#10;        return false;&#10;    }&#10;&#10;    return true;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>