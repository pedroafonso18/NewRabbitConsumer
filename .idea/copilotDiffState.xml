<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/include/Utils.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/Utils.h" />
              <option name="originalContent" value="#ifndef UTILS_H&#10;#define UTILS_H&#10;&#10;#include &lt;string&gt;&#10;&#10;class Utils {&#10;public:&#10;    Utils() = delete;&#10;    static void getTimestamp(std::string timestamp);&#10;};&#10;&#10;#endif //UTILS_H&#10;" />
              <option name="updatedContent" value="#ifndef UTILS_H&#10;#define UTILS_H&#10;&#10;#include &lt;string&gt;&#10;#include &lt;chrono&gt;&#10;&#10;class Utils {&#10;public:&#10;    Utils() = delete;&#10;    static std::chrono::system_clock::time_point getTimestamp(std::string timestamp);&#10;};&#10;&#10;#endif //UTILS_H" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/D_Insert.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/D_Insert.cpp" />
              <option name="originalContent" value="#include &quot;../include/D_Insert.h&quot;&#10;#include &lt;nlohmann/json.hpp&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;chrono&gt;&#10;#include &lt;ctime&gt;&#10;&#10;void Insert::insertEnqueued(Enqueued &amp;enqueued) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO queue(id, gs_id, recipient_id, status, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6)&quot;, enqueued.id, enqueued.gs_id, enqueued.recipient_id, enqueued.status,enqueued.gs_app_id, enqueued.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Enqueued.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertSent(Sent &amp;sent) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO sent(id, display_phone_number, phone_number_id, conversation_expiration_timestamp, conversation_id, conversation_type, gs_id, meta_msg_id, pricing_billable, pricing_category, pricing_model, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)&quot;,&#10;            sent.id, sent.display_phone_number, sent.phone_number_id, sent.conversation_expiration_timestamp, sent.conversation_id, sent.conversation_type, sent.gs_id, sent.meta_msg_id, sent.pricing_billable, sent.pricing_category, sent.pricing_model, sent.recipient_id, sent.status, sent.changes_id, sent.gs_app_id, sent.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Sent.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertDelivered(Delivered &amp;delivered) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO delivered(id, display_phone_number, phone_number_id, conversation_id, conversation_type, gs_id, meta_msg_id, pricing_billable, pricing_category, pricing_model, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) ON CONFLICT (id) DO NOTHING&quot;, delivered.id, delivered.display_phone_number, delivered.phone_number_id, delivered.conversation_id, delivered.conversation_id, delivered.conversation_id, delivered.conversation_type, delivered.gs_id, delivered.meta_msg_id, delivered.pricing_billable, delivered.pricing_category, delivered.pricing_model, delivered.recipient_id, delivered.status, delivered.changes_id, delivered.gs_app_id, delivered.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Delivered.\n&quot;;&#10;        }&#10;&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertRead(Read &amp;read) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO read(id, display_phone_number, phone_number_id, gs_id, meta_msg_id, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) ON CONFLICT (id) DO NOTHING&quot;, read.id, read.display_phone_number, read.phone_number_id, read.gs_id, read.meta_msg_id, read.recipient_id, read.status, read.changes_id, read.status, read.changes_id, read.gs_app_id, read.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Read.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertFailed(Failed &amp;failed) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO failed(id, display_phone_number, phone_number_id, erro_code, erro_details, erro_message, title, gs_id, meta_msg_id, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)&quot;, failed.id, failed.display_phone_number, failed.phone_number_id, failed.error_code, failed.error_details, failed.error_message, failed.title, failed.gs_id, failed.meta_msg_id, failed.recipient_id, failed.recipient_id, failed.status, failed.changes_id, failed.gs_app_id, failed.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Failed.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertUnmapped(std::string &amp;data) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO unmapped(valor) VALUES ($1)&quot;, data);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Unmapped.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertTemplateError(TemplateError &amp;err) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO template_errors(gs_id, recipient_id, error_code, error_title, status, timestamp, raw_json) VALUES ($1, $2, $3, $4, $5, $6, $7)&quot;, err.gs_id, err.recipient_id, err.error_code, err.error_title, err.status, err.timestamp, err.raw_json);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting TemplateError.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertErrorPayload(std::string &amp;payload) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    try {&#10;        nlohmann::json error_json = nlohmann::json::parse(payload);&#10;&#10;        if (error_json.contains(&quot;gs_id&quot;) &amp;&amp; error_json[&quot;gs_id&quot;].is_string() &amp;&amp;&#10;            error_json.contains(&quot;recipient_id&quot;) &amp;&amp; error_json[&quot;recipient_id&quot;].is_string() &amp;&amp;&#10;            error_json.contains(&quot;status&quot;) &amp;&amp; error_json[&quot;status&quot;].is_string() &amp;&amp;&#10;            error_json.contains(&quot;timestamp&quot;) &amp;&amp; error_json[&quot;timestamp&quot;].is_number()) {&#10;&#10;            std::string gs_id_str = error_json[&quot;gs_id&quot;].get&lt;std::string&gt;();&#10;            std::string recipient_id = error_json[&quot;recipient_id&quot;].get&lt;std::string&gt;();&#10;            std::string status = error_json[&quot;status&quot;].get&lt;std::string&gt;();&#10;            int64_t timestamp_val = error_json[&quot;timestamp&quot;].get&lt;int64_t&gt;();&#10;&#10;            int64_t timestamp_secs = timestamp_val / 1000;&#10;&#10;            time_t time_val = static_cast&lt;time_t&gt;(timestamp_secs);&#10;            char time_buf[30];&#10;            std::strftime(time_buf, sizeof(time_buf), &quot;%Y-%m-%d %H:%M:%S&quot;, std::gmtime(&amp;time_val));&#10;            std::string timestamp_str(time_buf);&#10;&#10;            if (error_json.contains(&quot;errors&quot;) &amp;&amp; error_json[&quot;errors&quot;].is_array() &amp;&amp; !error_json[&quot;errors&quot;].empty()) {&#10;                const nlohmann::json&amp; first_error = error_json[&quot;errors&quot;][0];&#10;&#10;                int error_code = 0;&#10;                if (first_error.contains(&quot;code&quot;) &amp;&amp; first_error[&quot;code&quot;].is_number()) {&#10;                    error_code = first_error[&quot;code&quot;].get&lt;int&gt;();&#10;                }&#10;&#10;                std::string error_title = &quot;Unknown error&quot;;&#10;                if (first_error.contains(&quot;title&quot;) &amp;&amp; first_error[&quot;title&quot;].is_string()) {&#10;                    error_title = first_error[&quot;title&quot;].get&lt;std::string&gt;();&#10;                }&#10;&#10;                TemplateError err;&#10;                err.gs_id = gs_id_str;&#10;                err.recipient_id = recipient_id;&#10;                err.error_code = error_code;&#10;                err.error_title = error_title;&#10;                err.status = status;&#10;                err.timestamp = timestamp_str;&#10;                err.raw_json = payload;&#10;&#10;                insertTemplateError(err);&#10;                return;&#10;            }&#10;        }&#10;    } catch (const nlohmann::json::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;JSON parsing error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;Error processing payload: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;    }&#10;&#10;    insertUnmapped(payload);&#10;}&#10;&#10;void Insert::insertMessageLogs(MessageLog &amp;log) {&#10;    std::clog &lt;&lt; &quot;STEAK: Attempting to insert message into logs database - WAMID: &quot; &lt;&lt; log.wamid &lt;&lt; '\n';&#10;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;&#10;    auto utc_timestamp = std::chrono::&#10;&#10;    try {&#10;        transaction.exec(&quot;SET statement_timeout = '30s'&quot;);&#10;        transaction.exec(&quot;SET idle_in_transaction_session_timeout = '30s'&quot;);&#10;        auto result = transaction.exec_params(&quot;INSERT INTO logstrafegohuggy( wamid, contact_wa_id, msg_text, timestamp, type, display_phone_number, phone_number_id, changes_id, gs_app_id, ctwa_clid, app, version, phone, name, country_code, dial_code, headline, referral_body, source_type, source_id, source_url, media_type, video_url, thumbnail_url, tag ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25)&quot;, log.wamid, log.contact_wa_id, log.msg_text, log.msg_timestamp, log.)&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/D_Insert.h&quot;&#10;#include &lt;nlohmann/json.hpp&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;chrono&gt;&#10;#include &lt;ctime&gt;&#10;&#10;void Insert::insertEnqueued(Enqueued &amp;enqueued) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO queue(id, gs_id, recipient_id, status, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6)&quot;, enqueued.id, enqueued.gs_id, enqueued.recipient_id, enqueued.status,enqueued.gs_app_id, enqueued.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Enqueued.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertSent(Sent &amp;sent) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO sent(id, display_phone_number, phone_number_id, conversation_expiration_timestamp, conversation_id, conversation_type, gs_id, meta_msg_id, pricing_billable, pricing_category, pricing_model, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)&quot;,&#10;            sent.id, sent.display_phone_number, sent.phone_number_id, sent.conversation_expiration_timestamp, sent.conversation_id, sent.conversation_type, sent.gs_id, sent.meta_msg_id, sent.pricing_billable, sent.pricing_category, sent.pricing_model, sent.recipient_id, sent.status, sent.changes_id, sent.gs_app_id, sent.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Sent.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertDelivered(Delivered &amp;delivered) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO delivered(id, display_phone_number, phone_number_id, conversation_id, conversation_type, gs_id, meta_msg_id, pricing_billable, pricing_category, pricing_model, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15) ON CONFLICT (id) DO NOTHING&quot;, delivered.id, delivered.display_phone_number, delivered.phone_number_id, delivered.conversation_id, delivered.conversation_id, delivered.conversation_id, delivered.conversation_type, delivered.gs_id, delivered.meta_msg_id, delivered.pricing_billable, delivered.pricing_category, delivered.pricing_model, delivered.recipient_id, delivered.status, delivered.changes_id, delivered.gs_app_id, delivered.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Delivered.\n&quot;;&#10;        }&#10;&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertRead(Read &amp;read) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO read(id, display_phone_number, phone_number_id, gs_id, meta_msg_id, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) ON CONFLICT (id) DO NOTHING&quot;, read.id, read.display_phone_number, read.phone_number_id, read.gs_id, read.meta_msg_id, read.recipient_id, read.status, read.changes_id, read.status, read.changes_id, read.gs_app_id, read.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Read.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertFailed(Failed &amp;failed) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO failed(id, display_phone_number, phone_number_id, erro_code, erro_details, erro_message, title, gs_id, meta_msg_id, recipient_id, status, changes_id, gs_app_id, timestamp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)&quot;, failed.id, failed.display_phone_number, failed.phone_number_id, failed.error_code, failed.error_details, failed.error_message, failed.title, failed.gs_id, failed.meta_msg_id, failed.recipient_id, failed.recipient_id, failed.status, failed.changes_id, failed.gs_app_id, failed.timestamp);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Failed.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertUnmapped(std::string &amp;data) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO unmapped(valor) VALUES ($1)&quot;, data);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting Unmapped.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertTemplateError(TemplateError &amp;err) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;    try {&#10;        auto result = transaction.exec_params(&quot;INSERT INTO template_errors(gs_id, recipient_id, error_code, error_title, status, timestamp, raw_json) VALUES ($1, $2, $3, $4, $5, $6, $7)&quot;, err.gs_id, err.recipient_id, err.error_code, err.error_title, err.status, err.timestamp, err.raw_json);&#10;        if (!result.affected_rows() == 0) {&#10;            std::clog &lt;&lt; &quot;ERROR: error when inserting TemplateError.\n&quot;;&#10;        }&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}&#10;&#10;void Insert::insertErrorPayload(std::string &amp;payload) {&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    try {&#10;        nlohmann::json error_json = nlohmann::json::parse(payload);&#10;&#10;        if (error_json.contains(&quot;gs_id&quot;) &amp;&amp; error_json[&quot;gs_id&quot;].is_string() &amp;&amp;&#10;            error_json.contains(&quot;recipient_id&quot;) &amp;&amp; error_json[&quot;recipient_id&quot;].is_string() &amp;&amp;&#10;            error_json.contains(&quot;status&quot;) &amp;&amp; error_json[&quot;status&quot;].is_string() &amp;&amp;&#10;            error_json.contains(&quot;timestamp&quot;) &amp;&amp; error_json[&quot;timestamp&quot;].is_number()) {&#10;&#10;            std::string gs_id_str = error_json[&quot;gs_id&quot;].get&lt;std::string&gt;();&#10;            std::string recipient_id = error_json[&quot;recipient_id&quot;].get&lt;std::string&gt;();&#10;            std::string status = error_json[&quot;status&quot;].get&lt;std::string&gt;();&#10;            int64_t timestamp_val = error_json[&quot;timestamp&quot;].get&lt;int64_t&gt;();&#10;&#10;            int64_t timestamp_secs = timestamp_val / 1000;&#10;&#10;            time_t time_val = static_cast&lt;time_t&gt;(timestamp_secs);&#10;            char time_buf[30];&#10;            std::strftime(time_buf, sizeof(time_buf), &quot;%Y-%m-%d %H:%M:%S&quot;, std::gmtime(&amp;time_val));&#10;            std::string timestamp_str(time_buf);&#10;&#10;            if (error_json.contains(&quot;errors&quot;) &amp;&amp; error_json[&quot;errors&quot;].is_array() &amp;&amp; !error_json[&quot;errors&quot;].empty()) {&#10;                const nlohmann::json&amp; first_error = error_json[&quot;errors&quot;][0];&#10;&#10;                int error_code = 0;&#10;                if (first_error.contains(&quot;code&quot;) &amp;&amp; first_error[&quot;code&quot;].is_number()) {&#10;                    error_code = first_error[&quot;code&quot;].get&lt;int&gt;();&#10;                }&#10;&#10;                std::string error_title = &quot;Unknown error&quot;;&#10;                if (first_error.contains(&quot;title&quot;) &amp;&amp; first_error[&quot;title&quot;].is_string()) {&#10;                    error_title = first_error[&quot;title&quot;].get&lt;std::string&gt;();&#10;                }&#10;&#10;                TemplateError err;&#10;                err.gs_id = gs_id_str;&#10;                err.recipient_id = recipient_id;&#10;                err.error_code = error_code;&#10;                err.error_title = error_title;&#10;                err.status = status;&#10;                err.timestamp = timestamp_str;&#10;                err.raw_json = payload;&#10;&#10;                insertTemplateError(err);&#10;                return;&#10;            }&#10;        }&#10;    } catch (const nlohmann::json::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;JSON parsing error: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;    } catch (const std::exception&amp; e) {&#10;        std::clog &lt;&lt; &quot;Error processing payload: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;&#10;    }&#10;&#10;    insertUnmapped(payload);&#10;}&#10;&#10;void Insert::insertMessageLogs(MessageLog &amp;log) {&#10;    std::clog &lt;&lt; &quot;STEAK: Attempting to insert message into logs database - WAMID: &quot; &lt;&lt; log.wamid &lt;&lt; '\n';&#10;&#10;    auto c = db-&gt;getConnection();&#10;    if (!c-&gt;is_open()) {&#10;        std::clog &lt;&lt; &quot;ERROR: db connection is not open.\n&quot;;&#10;        throw std::runtime_error(&quot;DB CONNECTION IS NOT ACTIVE&quot;);&#10;    }&#10;    pqxx::work transaction(*c);&#10;&#10;    auto utc_timestamp = std::chrono::system_clock::from_time_t(&#10;        std::chrono::system_clock::to_time_t(&#10;            std::chrono::system_clock::now()));  // Default to current time if conversion fails&#10;    &#10;    // Convert log.msg_timestamp string to a time_point if available&#10;    if (!log.msg_timestamp.empty()) {&#10;        std::tm tm = {};&#10;        std::istringstream ss(log.msg_timestamp);&#10;        ss &gt;&gt; std::get_time(&amp;tm, &quot;%Y-%m-%d %H:%M:%S&quot;);&#10;        &#10;        if (!ss.fail()) {&#10;            utc_timestamp = std::chrono::system_clock::from_time_t(std::mktime(&amp;tm));&#10;        }&#10;    }&#10;&#10;    try {&#10;        transaction.exec(&quot;SET statement_timeout = '30s'&quot;);&#10;        transaction.exec(&quot;SET idle_in_transaction_session_timeout = '30s'&quot;);&#10;        auto result = transaction.exec_params(&quot;INSERT INTO logstrafegohuggy( wamid, contact_wa_id, msg_text, timestamp, type, display_phone_number, phone_number_id, changes_id, gs_app_id, ctwa_clid, app, version, phone, name, country_code, dial_code, headline, referral_body, source_type, source_id, source_url, media_type, video_url, thumbnail_url, tag ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25)&quot;, log.wamid, log.contact_wa_id, log.msg_text, log.msg_timestamp, log.)&#10;    } catch (pqxx::sql_error&amp; e) {&#10;        transaction.abort();&#10;        throw std::runtime_error(&quot;Database error: &quot; + std::string(e.what()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/Utils.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/Utils.cpp" />
              <option name="originalContent" value="#include &quot;../include/Utils.h&quot;&#10;#include &lt;chrono&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;ctime&gt;&#10;#icnlude&#10;#include &lt;sstream&gt;&#10;&#10;std::chrono::system_clock::time_point Utils::getTimestamp(std::string timestamp) {&#10;    auto utc_timestamp = std::chrono::system_clock::from_time_t(&#10;    std::chrono::system_clock::to_time_t(&#10;        std::chrono::system_clock::now()));&#10;    &#10;    if (!timestamp.empty()) {&#10;        std::tm tm = {};&#10;        std::istringstream ss(timestamp);&#10;        ss &gt;&gt; std::get_time(&amp;tm, &quot;%Y-%m-%d %H:%M:%S&quot;);&#10;        &#10;        if (!ss.fail()) {&#10;            utc_timestamp = std::chrono::system_clock::from_time_t(std::mktime(&amp;tm));&#10;        }&#10;    }&#10;&#10;    return utc_timestamp;&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;../include/Utils.h&quot;&#10;#include &lt;chrono&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;ctime&gt;&#10;#include &lt;sstream&gt;&#10;#include &lt;iomanip&gt;  // For std::get_time&#10;&#10;std::chrono::system_clock::time_point Utils::getTimestamp(std::string timestamp) {&#10;    auto utc_timestamp = std::chrono::system_clock::from_time_t(&#10;    std::chrono::system_clock::to_time_t(&#10;        std::chrono::system_clock::now()));&#10;    &#10;    if (!timestamp.empty()) {&#10;        std::tm tm = {};&#10;        std::istringstream ss(timestamp);&#10;        ss &gt;&gt; std::get_time(&amp;tm, &quot;%Y-%m-%d %H:%M:%S&quot;);&#10;        &#10;        if (!ss.fail()) {&#10;            utc_timestamp = std::chrono::system_clock::from_time_t(std::mktime(&amp;tm));&#10;        }&#10;    }&#10;&#10;    return utc_timestamp;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>